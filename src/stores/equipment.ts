/**
 * Ë£ÖÂ§áÁÆ°ÁêÜStore
 * ÁÆ°ÁêÜÊâÄÊúâË£ÖÂ§áÂàÜÁ±ªÂíåÈ°πÁõÆÊï∞ÊçÆ
 */
import { defineStore } from 'pinia';
import { ref, computed, watch, WatchStopHandle } from 'vue';
import { useStorage, useRefHistory } from '@vueuse/core';
import { useOperationLogStore } from './operationLog';
import { defaultCategories, localStorageKeys } from '../config/appConfig';
import { toast } from '../utils/toast';
import { v4 as uuidv4 } from 'uuid';

export interface Category {
  id: string;
  name: string;
  icon: string;
  items: Item[];
  collapsed: boolean;
}

interface Item {
  id: number | string;
  index: number;
  name: string;
  completed: boolean;
  quantity: number;
  quantityUnit: string;
  weight: number;
  weightUnit: string;
  price: number;
  priceUnit: string;
  isRecommended: boolean;
  notes: string;
  priority: string;
}

interface BeforeState {
  action: string;
  categories: Category[];
}

function reindexCategoryItems(category: Category): void {
  category.items.forEach((item, index) => {
    item.index = index + 1;
  });
  console.log(`üî¢ Re-indexing category "${category.name}" with ${category.items.length} items`);
}

function fixDuplicateItemIds(category: Category): number {
  const idSet = new Set<string | number>();
  let fixedCount = 0;
  category.items.forEach((item) => {
    if (idSet.has(item.id)) {
      const oldId = item.id;
      item.id = uuidv4();
      console.warn(`‚ö†Ô∏è Fixed duplicate ID: ${oldId} ‚Üí ${item.id} (Item: ${item.name})`);
      fixedCount++;
    }
    idSet.add(item.id);
  });
  if (fixedCount > 0) {
    console.log(`‚úÖ Fixed ${fixedCount} duplicate item IDs in category "${category.name}"`);
  }
  return fixedCount;
}

function migrateAndValidateData(data: Category[]): Category[] {
  let needsReindex = false;
  const validatedData = data.map(cat => {
    const items = cat.items.map((item, index) => {
      const updatedItem: Item = { ...item };
      if (typeof item.index !== 'number') {
        needsReindex = true;
        updatedItem.index = index + 1;
      }
      if (updatedItem.price === undefined) updatedItem.price = 0;
      if (!updatedItem.priceUnit) updatedItem.priceUnit = '‰∫∫Ê∞ëÂ∏Å';
      if (typeof item.id !== 'string') updatedItem.id = uuidv4();
      return updatedItem;
    });
    return { ...cat, icon: cat.icon || '‚ú®', items };
  });

  if (needsReindex) {
    console.log('üî¢ Re-indexing items...');
    validatedData.forEach(reindexCategoryItems);
  }

  let totalFixed = 0;
  validatedData.forEach(cat => {
    totalFixed += fixDuplicateItemIds(cat);
  });
  if (totalFixed > 0) {
    console.warn(`‚ö†Ô∏è Fixed ${totalFixed} duplicate item IDs.`);
  }

  console.log('‚úÖ Data loaded from storage and validated.');
  return validatedData;
}

function initializeDefaultCategories(): Category[] {
  console.log('üì¶ Initializing default categories...');
  const defaultData = defaultCategories.map((cat) => ({
    id: uuidv4(),
    name: cat.name,
    icon: cat.icon,
    items: [],
    collapsed: false,
  }));

  // Can't log here as the store is not yet available
  // Consider logging after initialization if needed
  
  return defaultData;
}

export const useEquipmentStore = defineStore('equipment', () => {
  const categories = useStorage<Category[]>(localStorageKeys.equipmentChecklist, [], localStorage, {
    mergeDefaults: (storageValue) => {
      if (storageValue && storageValue.length > 0) {
        return migrateAndValidateData(storageValue);
      }
      return initializeDefaultCategories();
    },
  });

  const { history, undo, redo, canUndo, canRedo } = useRefHistory(categories, {
    deep: true,
    capacity: 20,
  });

  const groupByStatus = ref<boolean>(true);
  const hasLoaded = ref<boolean>(false);

  let stopWatch: WatchStopHandle | undefined;

  stopWatch = watch(
    categories,
    (value) => {
      if (value) {
        hasLoaded.value = true;
        if (stopWatch) {
            stopWatch();
        }
      }
    },
    { immediate: true, deep: true }
  );
  
  const totalCategories = computed<number>(() => categories.value.length);

  const totalItems = computed<number>(() =>
    categories.value.reduce((sum, cat) => sum + cat.items.length, 0)
  );

  const completedItems = computed<number>(() =>
    categories.value.reduce(
      (sum, cat) => sum + cat.items.filter((item) => item.completed).length,
      0
    )
  );

  const remainingItems = computed<number>(() => totalItems.value - completedItems.value);

  const totalWeight = computed<string>(() => {
    const weightInGrams = categories.value.reduce(
      (sum, cat) =>
        sum +
        cat.items.reduce((itemSum, item) => {
          let weightInGrams: number = item.weight;
          // Âçï‰ΩçËΩ¨Êç¢
          switch (item.weightUnit) {
            case 'kg': weightInGrams = item.weight * 1000; break;
            case 'Êñ§': weightInGrams = item.weight * 500; break;
            case 'Á£Ö': weightInGrams = item.weight * 453.592; break;
            default: weightInGrams = item.weight; // g
          }
          return itemSum + weightInGrams * item.quantity;
        }, 0),
      0
    );
    return (weightInGrams / 1000).toFixed(2) + 'kg';
  });

  const totalPrice = computed<string>(() => {
    const priceInYuan = categories.value.reduce(
      (sum, cat) =>
        sum +
        cat.items.reduce((itemSum, item) => {
          let priceInYuan: number = item.price || 0;
          // Âçï‰ΩçËΩ¨Êç¢Âà∞‰∫∫Ê∞ëÂ∏Å
          switch (item.priceUnit) {
            case 'ÁæéÂÖÉ': priceInYuan = (item.price || 0) * 7; break; // ÁÆÄÂçïÊ±áÁéáËΩ¨Êç¢
            case 'Ëã±Èïë': priceInYuan = (item.price || 0) * 9; break;
            case 'Êó•ÂÖÉ': priceInYuan = (item.price || 0) * 0.05; break;
            default: priceInYuan = item.price || 0; // ‰∫∫Ê∞ëÂ∏Å
          }
          return itemSum + priceInYuan * item.quantity;
        }, 0),
      0
    );
    return priceInYuan.toFixed(2) + '‰∫∫Ê∞ëÂ∏Å';
  });

  /**
   * Ê∑ªÂä†ÂàÜÁ±ª
   * @param {string} name
   * @param {string} icon
   * @returns {boolean}
   */
  function addCategory(name: string, icon: string = '‚ú®'): boolean {
    if (!name || name.trim() === '') {
      toast.warning('ËØ∑ËæìÂÖ•ÂàÜÁ±ªÂêçÁß∞');
      return false;
    }

    const newCategory: Category = {
      id: uuidv4(),
      name: name.trim(),
      icon: icon,
      items: [],
      collapsed: false,
    };

    const logStore = useOperationLogStore();
    logStore.log('add', `Ê∑ªÂä†‰∫ÜÂàÜÁ±ªÔºö${name}`, { category: name });

    categories.value.push(newCategory);
    
    return true;
  }
  
  function editCategoryIcon(categoryId: string, newIcon: string): boolean {
    const category = categories.value.find((cat) => cat.id === categoryId);
    if (!category) return false;

    if (newIcon.trim() === category.icon) {
      return false;
    }

    const oldIcon = category.icon;
    const categoryName = category.name;
    
    undo();
    
    const categoryToUpdate = categories.value.find((cat) => cat.id === categoryId);
    if(categoryToUpdate) {
        categoryToUpdate.icon = newIcon.trim();
    }

    const logStore = useOperationLogStore();
    logStore.log(
      'edit',
      `‰øÆÊîπ‰∫ÜÂàÜÁ±ªÂõæÊ†áÔºö${categoryName}`,
      {
        category: categoryName,
        oldIcon: oldIcon,
        newIcon: newIcon,
      }
    );
    return true;
  }
  
  async function deleteCategory(categoryId: string): Promise<boolean> {
    const category = categories.value.find((cat) => cat.id === categoryId);
    if (!category) return false;

    const categoryName = category.name;
    const itemCount = category.items.length;

    const logStore = useOperationLogStore();
    logStore.log(
      'delete',
      `Âà†Èô§‰∫ÜÂàÜÁ±ªÔºö${categoryName}`,
      {
        category: categoryName,
        itemCount: itemCount,
      }
    );
    
    categories.value = categories.value.filter((cat) => cat.id !== categoryId);

    toast.success(`ÂàÜÁ±ª"${categoryName}"Â∑≤Âà†Èô§`);
    return true;
  }
  
  function editCategoryName(categoryId: string, newName: string): boolean {
    const category = categories.value.find((cat) => cat.id === categoryId);
    if (!category) return false;

    if (!newName || newName.trim() === '') {
      toast.warning('ÂàÜÁ±ªÂêçÁß∞‰∏çËÉΩ‰∏∫Á©∫');
      return false;
    }

    const oldName = category.name;
    
    undo();
    
    const categoryToUpdate = categories.value.find((cat) => cat.id === categoryId);
    if(categoryToUpdate) {
        categoryToUpdate.name = newName.trim();
    }

    const logStore = useOperationLogStore();
    logStore.log(
      'edit',
      `‰øÆÊîπ‰∫ÜÂàÜÁ±ªÂêçÁß∞Ôºö${oldName} ‚Üí ${newName}`,
      {
        oldName: oldName,
        newName: newName,
      }
    );

    toast.success(`ÂàÜÁ±ªÂêçÁß∞Â∑≤Êõ¥Êñ∞‰∏∫"${newName}"`);
    return true;
  }
  
  function toggleCategoryCollapse(categoryId: string): void {
    const category = categories.value.find((cat) => cat.id === categoryId);
    if (!category) return;

    category.collapsed = !category.collapsed;
  }
  
  function reindexCategory(categoryId: string): void {
    const category = categories.value.find((cat) => cat.id === categoryId);
    if (!category) return;

    reindexCategoryItems(category);
  }
  
  function fixDuplicateIds(categoryId: string): number {
    const category = categories.value.find((cat) => cat.id === categoryId);
    if (!category) return 0;

    return fixDuplicateItemIds(category);
  }
  
  function updateCategoriesOrder(newOrder: Category[]): void {
    const logStore = useOperationLogStore();
    logStore.log(
      'sort',
      'ÈáçÊñ∞ÊéíÂ∫è‰∫ÜÂàÜÁ±ª',
      {
        categories: newOrder.map((cat) => cat.name).join('„ÄÅ'),
      }
    );
    
    categories.value = newOrder;
  }
  
  function addItem(
    categoryId: string,
    itemData: Partial<Item> & { description?: string }
  ): boolean {
    const category = categories.value.find((cat) => cat.id === categoryId);
    if (!category) return false;

    if (!itemData.name || itemData.name.trim() === '') {
      toast.warning('ËØ∑ËæìÂÖ•Ë£ÖÂ§áÂêçÁß∞');
      return false;
    }

    const maxIndex = category.items.reduce(
      (max, item) => Math.max(max, item.index || 0),
      0
    );

    const newItem: Item = {
      id: uuidv4(),
      index: maxIndex + 1,
      name: itemData.name.trim(),
      completed: itemData.completed || false,
      quantity: itemData.quantity || 1,
      quantityUnit: itemData.quantityUnit || '‰∏™',
      weight: itemData.weight || 0,
      weightUnit: itemData.weightUnit || 'g',
      price: itemData.price || 0,
      priceUnit: itemData.priceUnit || '‰∫∫Ê∞ëÂ∏Å',
      isRecommended: itemData.isRecommended || false, // Êñ∞Â¢ûÂ≠óÊÆµÔºåÊ†áËÆ∞‰∏∫Êé®ËçêË£ÖÂ§á
      notes: itemData.description || itemData.notes || '', // ÊîØÊåÅ description Êàñ notes
      priority: itemData.priority || 'medium', // ÊîØÊåÅ‰ºòÂÖàÁ∫ß
    };

    const logStore = useOperationLogStore();
    logStore.log(
      'add',
      `Ê∑ªÂä†‰∫ÜË£ÖÂ§á #${newItem.index}Ôºö${newItem.name}`,
      {
        category: category.name,
        item: newItem.name,
        index: newItem.index,
        quantity: `${newItem.quantity}${newItem.quantityUnit}`,
        weight: `${newItem.weight}${newItem.weightUnit}`,
        price: `${newItem.price}${newItem.priceUnit}`,
      }
    );
    
    category.items.push(newItem);

    toast.success(`Ë£ÖÂ§á"${newItem.name}"Ê∑ªÂä†ÊàêÂäü`);
    return true;
  }
  
  async function deleteItem(
    categoryId: string,
    itemId: string | number
  ): Promise<boolean> {
    const category = categories.value.find((cat) => cat.id === categoryId);
    if (!category) return false;

    const item = category.items.find((i) => i.id === itemId);
    if (!item) return false;

    const logStore = useOperationLogStore();
    logStore.log(
      'delete',
      `Âà†Èô§‰∫ÜË£ÖÂ§á #${item.index}Ôºö${item.name}`,
      {
        category: category.name,
        item: item.name,
        index: item.index,
      }
    );
    
    category.items = category.items.filter((item) => item.id !== itemId);

    reindexCategory(categoryId);

    toast.success(`Ë£ÖÂ§á"${item.name}"Â∑≤Âà†Èô§`);
    return true;
  }
  
  async function removeItem(
    categoryId: string,
    itemId: string | number
  ): Promise<boolean> {
    const category = categories.value.find((cat) => cat.id === categoryId);
    if (!category) return false;

    const item = category.items.find((i) => i.id === itemId);
    if (!item) return false;

    const logStore = useOperationLogStore();
    logStore.log(
      'delete',
      `Âà†Èô§‰∫ÜË£ÖÂ§á #${item.index}Ôºö${item.name}`,
      {
        category: category.name,
        item: item.name,
        index: item.index,
      }
    );
    
    category.items = category.items.filter((item) => item.id !== itemId);

    reindexCategory(categoryId);

    toast.success(`Ë£ÖÂ§á"${item.name}"Â∑≤Âà†Èô§`);
    return true;
  }
  
  function editItem(
    categoryId: string,
    itemId: string | number,
    itemData: Partial<Item>
  ): boolean {
    const category = categories.value.find((cat) => cat.id === categoryId);
    if (!category) return false;

    const item = category.items.find((i) => i.id === itemId);
    if (!item) return false;

    if (!itemData.name || itemData.name.trim() === '') {
      toast.warning('ËØ∑ËæìÂÖ•Ë£ÖÂ§áÂêçÁß∞');
      return false;
    }

    const oldName = item.name;
    const oldQuantity = `${item.quantity}${item.quantityUnit}`;
    const oldWeight = `${item.weight}${item.weightUnit}`;
    const oldPrice = `${item.price || 0}${item.priceUnit || '‰∫∫Ê∞ëÂ∏Å'}`;

    undo();
    
    const itemToUpdate = category.items.find((i) => i.id === itemId);
    
    if(itemToUpdate) {
        itemToUpdate.name = itemData.name.trim();
        itemToUpdate.quantity = itemData.quantity || 1;
        itemToUpdate.quantityUnit = itemData.quantityUnit || '‰∏™';
        itemToUpdate.weight = itemData.weight || 0;
        itemToUpdate.weightUnit = itemData.weightUnit || 'g';
        itemToUpdate.price = itemData.price || 0;
        itemToUpdate.priceUnit = itemData.priceUnit || '‰∫∫Ê∞ëÂ∏Å';
    }


    const logStore = useOperationLogStore();
    logStore.log(
      'edit',
      `‰øÆÊîπ‰∫ÜË£ÖÂ§áÔºö${oldName} ‚Üí ${item.name}`,
      {
        category: category.name,
        oldName: oldName,
        newName: item.name,
        quantity: `${oldQuantity} ‚Üí ${item.quantity}${item.quantityUnit}`,
        weight: `${oldWeight} ‚Üí ${item.weight}${item.weightUnit}`,
        price: `${oldPrice} ‚Üí ${item.price}${item.priceUnit}`,
      }
    );

    toast.success(`Ë£ÖÂ§á"${item.name}"Â∑≤Êõ¥Êñ∞`);
    return true;
  }
  
  function updateEquipment(
    categoryId: string,
    itemId: string | number,
    itemData: Partial<Item>
  ): void {
    const category = categories.value.find((cat) => cat.id === categoryId);
    if (!category) return;
    const itemIndex = category.items.findIndex((i) => i.id === itemId);
    if (itemIndex === -1) return;
    category.items[itemIndex] = { ...category.items[itemIndex], ...itemData };
  }
  
  function toggleEquipmentStatus(
    categoryId: string,
    itemId: string | number
  ): boolean {
    const category = categories.value.find((cat) => cat.id === categoryId);
    if (!category) {
      console.error('‚ùå Êú™ÊâæÂà∞ÂàÜÁ±ª:', categoryId);
      return false;
    }

    const item = category.items.find((i) => i.id === itemId);
    if (!item) {
      console.error('‚ùå Êú™ÊâæÂà∞Ë£ÖÂ§á:', itemId, 'Âú®ÂàÜÁ±ª:', category.name);
      return false;
    }

    const logStore = useOperationLogStore();
    logStore.log(
      'toggle',
      `${item.completed ? 'Ê†áËÆ∞‰∏∫Â∑≤ÂáÜÂ§á' : 'Ê†áËÆ∞‰∏∫ÂæÖÂáÜÂ§á'}Ôºö${item.name}`,
      {
        category: category.name,
        item: item.name,
        status: item.completed ? 'Â∑≤ÂáÜÂ§á' : 'ÂæÖÂáÜÂ§á',
      }
    );
    
    item.completed = !item.completed;

    return true;
  }
  
  async function importData(data: Category[]): Promise<boolean> {
    if (!Array.isArray(data)) {
      toast.error('ÂØºÂÖ•ÁöÑÊï∞ÊçÆÊ†ºÂºè‰∏çÊ≠£Á°Æ');
      return false;
    }

    const oldCount = categories.value.length;

    categories.value = data.map((cat) => {
      const categoryData: Category = {
        ...cat,
        icon: cat.icon || '‚ú®',
        items: cat.items.map((item, index) => ({
          ...item,
          id: item.id && typeof item.id === 'string' ? item.id : uuidv4(),
          index: item.index || index + 1,
          price: item.price !== undefined ? item.price : 0,
          priceUnit: item.priceUnit || '‰∫∫Ê∞ëÂ∏Å',
        })),
      };
      return categoryData;
    });

    categories.value.forEach((cat) => {
      reindexCategory(cat.id);
    });

    let totalFixed = 0;
    categories.value.forEach((cat) => {
      totalFixed += fixDuplicateIds(cat.id);
    });

    if (totalFixed > 0) {
      console.warn(`‚ö†Ô∏è ÂØºÂÖ•Êï∞ÊçÆÊó∂‰øÆÂ§ç‰∫Ü ${totalFixed} ‰∏™ÈáçÂ§çÁöÑË£ÖÂ§áID`);
    }

    const logStore = useOperationLogStore();
    logStore.log('import', 'ÂØºÂÖ•‰∫ÜË£ÖÂ§áÊ∏ÖÂçïÊï∞ÊçÆ', {
      oldCategories: oldCount,
      newCategories: categories.value.length,
      totalItems: totalItems.value,
    });

    console.log('‚úÖ Êï∞ÊçÆÂØºÂÖ•ÂÆåÊàêÔºåÂ∑≤‰∏∫ÊâÄÊúâË£ÖÂ§áÂàÜÈÖçÂ∫èÂè∑');
    return true;
  }
  
  function clearAllData(): boolean {
    const oldCategories = categories.value.length;
    const oldItems = totalItems.value;

    categories.value = [];

    const logStore = useOperationLogStore();
    logStore.log('clear', 'Ê∏ÖÁ©∫‰∫ÜÊâÄÊúâË£ÖÂ§áÊï∞ÊçÆ', {
      deletedCategories: oldCategories,
      deletedItems: oldItems,
    });

    return true;
  }
  
  function toggleGroupByStatus(): void {
    groupByStatus.value = !groupByStatus.value;
  }
  
  function quickUndo(): boolean {
    if (canUndo.value) {
      undo();
      toast.success('Êìç‰ΩúÂ∑≤Êí§ÈîÄ');
      return true;
    }
    toast.info('Ê≤°ÊúâÂèØ‰ª•Êí§ÈîÄÁöÑÊìç‰Ωú');
    return false;
  }
  
  function getLatestUndoableLog(): object | undefined {
    const logStore = useOperationLogStore();
    return logStore.getLatestUndoableLog();
  }
  
  function getOrCreateCategory(categoryName: string, icon: string = '‚ú®'): string {
    let category = categories.value.find((cat) => cat.name === categoryName);
    if (!category) {
      const newCategory: Category = {
        id: uuidv4(),
        name: categoryName,
        icon: icon,
        items: [],
        collapsed: false,
      };
      categories.value.push(newCategory);
      const logStore = useOperationLogStore();
      logStore.log('add', `Ëá™Âä®ÂàõÂª∫‰∫ÜÂàÜÁ±ªÔºö${categoryName}`, {
        category: categoryName,
      });
      return newCategory.id;
    }
    return category.id;
  }

  return {
    categories,
    groupByStatus,
    hasLoaded,
    totalCategories,
    totalItems,
    completedItems,
    remainingItems,
    totalWeight,
    totalPrice,
    initializeCategories: initializeDefaultCategories,
    addCategory,
    deleteCategory,
    editCategoryName,
    editCategoryIcon,
    toggleCategoryCollapse,
    reindexCategory,
    fixDuplicateIds,
    updateCategoriesOrder,
    addItem,
    deleteItem,
    editItem,
    updateEquipment,
    toggleEquipmentStatus,
    toggleItem: toggleEquipmentStatus,
    toggleGroupByStatus,
    importData,
    clearAllData,
    undo,
    redo,
    canUndo,
    canRedo,
    quickUndo, // Âø´ÈÄüÊí§ÈîÄÊúÄËøëÊìç‰Ωú
    getLatestUndoableLog, // Êö¥Èú≤Ëé∑ÂèñÊúÄÊñ∞ÂèØÊí§ÈîÄÊó•ÂøóÊñπÊ≥ï
    getOrCreateCategory, // Êö¥Èú≤Ëé∑ÂèñÊàñÂàõÂª∫ÂàÜÁ±ªÊñπÊ≥ï
    removeItem,
  };
});

